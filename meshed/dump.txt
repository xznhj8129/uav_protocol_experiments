# node_uav.py

```

#!/usr/bin/env python3

"""
Demonstrates direct, brokerless messaging across a Meshtastic LoRa mesh,
using MessagePack (msgpack) for compact encoding of Python dictionaries.
For control and communications between air and ground swarm nodes"""

import time
import msgpack
import asyncio
import socket
import time
from collections import deque
from itertools import cycle 
from unavlib.control import UAVControl
from unavlib.control import geospatial #??????????
from unavlib.modules import geospatial
from unavlib.modules.utils import inavutil
from unavlib.modules.fast_functions import fastMSP
from unavlib import MSPy
from frogtastic import MeshtasticClient

from protocol import *
from froggeolib import *
from frogtastic import *


def list_to_int(indices):
    bitmap = 0
    for i in indices:
        bitmap |= (1 << i)  # Set the bit at position i
    return bitmap

def int_to_list(bitmap):
    return [i for i in range(bitmap.bit_length()) if (bitmap & (1 << i)) != 0]



SERIAL_PORT = '/dev/ttyUSB0'
uav_id = client.meshint.getMyNodeInfo()["user"]["id"]
gcs_id = "!55c7628c"
SEND_INTERVAL
link_port = 333 # Port for private apps (256-511)
preload_modes = [27, 10, 12, 38]
#my_pos = GPSposition(lat=15.83345500, lon=20.89884100, alt=50)



async def main():

    client = MeshtasticClient(SERIAL_PORT)
    nodes = nodes = client.meshint.nodes
    print(f"[INIT] Connected to Meshtastic node. My node ID: 0x{my_id}")
    print(client.meshint.getMyNodeInfo())

    mydrone = UAVControl(
        device='/dev/ttyS0',
        baudrate=115200,
        platform="AIRPLANE"
    )
    
    mydrone.msp_receiver = False
    mini_modes = preload_modes.copy()
    try:
        await mydrone.connect()
        await mydrone.telemetry_init()
        print("Connected to the flight controller")

        mydrone.load_modes_config()
        for i in mydrone.modes:
            if i not in preload_modes:
                mini_modes.append(i)
        print('Modes bitmap:', mini_modes)
        for i in mini_modes:
            print(i, inavutil.modesID.get(i))


        while True:

            analog = mydrone.get_analog()
            modes = mydrone.get_board_modes()
            activemodes = []
            for i in range(len(mini_modes)):
                if mini_modes[i] in modes:
                    activemodes.append(i)
            modemap = list_to_int(activemodes)

            msg_id = messageid(Messages.Status.System.FLIGHT)
            gpsd = mydrone.get_gps_data()
            speed = gpsd['speed']
            alt = mydrone.get_altitude()
            pos = geospatial.GPSposition(gpsd['lat'], gpsd['lon'], alt)
            gyro = mydrone.get_attitude()
            navstatus = mydrone.get_nav_status()
            rc = mydrone.get_rc_channels()
            voltage = analog ["voltage"]
            amps = analog["amperage"]

            print("\tChannels:",rc)
            print('\tModes:', modemap, [inavutil.modesID.get(i) for i in modes])
            print('\tPosition:', pos)
            print('\tAttitude:', gyro)
            print('\tAltitude:', alt)
            print('\tGPS Altitude:',gpsd["alt"])
            print("\tNavstatus:", navstatus)
            print("\tGPS Data:",gpsd)
            print("\tVbatt:",voltage)
            print("\tVbatt:",amps)
            
            # here you would generate the telemetry message according to the message definition
            message_dict = {}
            

            encoded_message = msgpack.dumps(message_dict)
            print("msg len:",len(encoded_message))

            client.meshint.sendData(
                encoded_message, 
                destinationId=GCS_id, 
                portNum=link_port, 
                wantAck=True)

            # check messages
            messages = client.checkMail()
            for msg in messages:
                if msg["portnum"] == link_port:
                    try:
                        msg = msgpack.loads(raw_data, strict_map_key=False)
                    except Exception as e:
                        print(f"[RECEIVED] Unrecognized binary data fromId={msg.get('from')}. Error: {e}")

            await asyncio.sleep(1)  

    except IOError as e:
        print(f"Error: {e}")
    except KeyboardInterrupt:
        print("Shutdown")
    finally:
        # Clean up
        mydrone.stop()
        client.meshint.close()
        print("Connection closed")

# Run the main function
if __name__ == '__main__':
    asyncio.run(main())
```

# node_controller.py

```

from frogtastic import *
import time
from unavlib.modules.utils import inavutil

def int_to_list(bitmap):
    return [i for i in range(bitmap.bit_length()) if (bitmap & (1 << i)) != 0]

client = MeshtasticClient('/dev/ttyACM1')
print("Connected to Meshtastic")
print(client.meshint.getMyNodeInfo())

# Mode presets: must be shared before flight
modemap = [27, 10, 12, 38, 0, 1, 53, 11, 31, 47]

while True:
    msgs = client.checkMail()
    if msgs: 
        #print(round(time.time()), msgs)
        for msg in msgs:
            if msg['port'] == 333:

                decoded_msg = None
                mt = msg['time']
                print()
                print('sender',msg['sender'])
                print('senderid',msg['senderid'])
                print('snr',msg['snr'])
                print('rssi',msg['rssi'])

                decoded_msg = somehow_decode(msg["data"][0])
                if decoded_msg:
                    # Convert the decoded message to a dictionary of its fields
                    mdict = decoded_msg.to_dict()
                    print("time:", time.time() - mdict["timestamp"])
                    
                    for i in mdict:
                        print(f"\t{i}\t{mdict[i]}")
                    modes = int_to_list(mdict["custom_mode"])
                    activemodes = []
                    for i in modes:
                        activemodes.append(modemap[i])
                    print('Modes:',[inavutil.modesID.get(i) for i in activemodes])

                else:
                    print("No valid message decoded.")

    time.sleep(0.1)

client.meshint.close()
```

# protocol.py

```

from enum import Enum, IntEnum, auto, IntFlag
import struct
import time
from typing import Any, Dict, List
from enum import Enum, IntEnum, auto
from typing import List, Dict, Tuple, Optional, Any
from definitions import MessageDefinitions
from message_structure import *
from payload_enums import *

def messageid(msg):
    # Get the enum class (e.g., Messages.Command.Mission)
    enum_class = msg.__class__
    # Get the qualified name (e.g., 'Messages.Command.Mission')
    qualname = enum_class.__qualname__
    # Split into parts: ['Messages', 'Command', 'Mission']
    parts = qualname.split('.')
    # Ensure it's the expected structure
    if len(parts) != 3 or parts[0] != 'Messages':
        raise ValueError("Invalid message enum")
    category_name = parts[1]  # e.g., 'Command'
    subcategory_name = parts[2]  # e.g., 'Mission'
    
    # Get category value from MessageCategory
    category_enum = getattr(MessageCategory, category_name)
    category_value = category_enum.value
    
    # Get subcategory value from Messages.Category.Subcategory.value
    category_class = getattr(Messages, category_name)
    subcategory_class = getattr(category_class, subcategory_name)
    subcategory_value = subcategory_class.value
    
    # Get message value from the enum member itself
    message_value = msg.value
    
    return (category_value, subcategory_value, message_value)
```

# payload_enums.py

```

from enum import Enum, IntEnum, auto

# ========== Reply PAYLOAD BYTE DEFINITIONS ==========
class PayloadEnum:
    class FlightMode(IntEnum):
        ACRO = auto()
        ANGLE = auto()
        CRUISE = auto()
        AUTO = auto()
        
    class CommandResult(IntEnum):
        # Reply to Command
        ACCEPTED = auto()
        TEMPORARILY_REJECTED = auto()
        DENIED = auto()
        UNSUPPORTED = auto()
        FAILED = auto()
        IN_PROGRESS = auto()
        CANCELLED = auto()

    class DataError(IntEnum):
        # Reply to Data
        NOT_FOUND = auto()
        DEVICE_UNAVAILABLE = auto()
        HARDWARE_ERROR = auto()
        SOFTWARE_ERROR = auto()
        DATABSE_ERROR = auto()

    class Enum_Flight_Phase(IntEnum):
        PREFLIGHT = auto()
        TAKEOFF = auto()
        CRUISE = auto()
        MISSION_OPERATION = auto()
        RTB = auto()
        LANDING = auto()
        POSTFLIGHT = auto()

    class Enum_Mission_Phase(IntEnum):
        BOOTING = auto()
        ONLINE = auto()
        MISSION_RECEIVED = auto()
        READY_TAKEOFF = auto()
        TAKEOFF_COMPLETE = auto()
        ENROUTE = auto()
        AT_ASSEMBLY = auto()
        HOLDING = auto()
        PROCEEDING = auto()
        BINGO = auto()
        RTB = auto()
        LANDING = auto()
        LANDED = auto()
        SHUTDOWN = auto()


```

# message_structure.py

```

from enum import Enum, auto

# This file is auto generated, refer to definitions.py

class MessageCategory(Enum):
    Heartbeat = 1
    Status = 2
    Command = 3
    Event = 4
    Data = 5

class Messages:
    class Heartbeat:
        class System(Enum):
            HEARTBEAT = auto()
    class Status:
        class Mission(Enum):
            MISSION_PHASE = auto()
        class System(Enum):
            FLIGHT = auto()
            POSITION = auto()
            NAVIGATION = auto()
            FUEL = auto()
            CONTROL = auto()
            SYSTEMS = auto()
            NAV = auto()
            RADIO = auto()
            PAYLOAD = auto()
    class Command:
        class System(Enum):
            ACTIVATE = auto()
            SHUTDOWN = auto()
            SET_FLIGHT_MODE = auto()
            SWITCH_DATALINK = auto()
            DATALINK_CONFIG = auto()
            SET_FLIGHT_PARAMETERS = auto()
        class Mission(Enum):
            SET_MISSION = auto()
            SET_MISSION_MODE = auto()
            TAKEOFF = auto()
            ABORT = auto()
            HOLD = auto()
            PROCEED = auto()
            REROUTE = auto()
            REASSIGN = auto()
            SET_WAYPOINT = auto()
            SET_ZONE = auto()
            NAVIGATE_TO = auto()
            LOITER = auto()
            LAND = auto()
            ALLOW_DEPLOY = auto()
            ALLOW_ENGAGE = auto()
            SWARM_CONTROL = auto()
    class Event:
        class Mission(Enum):
            PHASE = auto()
        class System(Enum):
            ONLINE = auto()
            GPS_FIX = auto()
            ERROR = auto()
            RADIO = auto()
            RF_EVENT = auto()
            FAILSAFE = auto()
            HW_FAILURE = auto()
    class Data:
        class Mission(Enum):
            QUERY_MISSION_ID = auto()
            QUERY_MISSION_PROGRESS = auto()
            QUERY_CONTACTS = auto()
            QUERY_SWARM_INFO = auto()
        class System(Enum):
            QUERY_SENSOR_DATA = auto()
            QUERY_LOG_DATA = auto()
            QUERY_DATALINK_STATUS = auto()
            QUERY_NETWORK_STATUS = auto()
            QUERY_SYSTEM_HEALTH = auto()
            QUERY_TELEMETRY = auto()


Messages.Heartbeat.System.value = 1
Messages.Heartbeat.System.str = 'System'
Messages.Status.Mission.value = 1
Messages.Status.Mission.str = 'Mission'
Messages.Status.System.value = 2
Messages.Status.System.str = 'System'
Messages.Command.System.value = 1
Messages.Command.System.str = 'System'
Messages.Command.Mission.value = 2
Messages.Command.Mission.str = 'Mission'
Messages.Event.Mission.value = 1
Messages.Event.Mission.str = 'Mission'
Messages.Event.System.value = 2
Messages.Event.System.str = 'System'
Messages.Data.Mission.value = 1
Messages.Data.Mission.str = 'Mission'
Messages.Data.System.value = 2
Messages.Data.System.str = 'System'
Messages.Heartbeat.value = 1
Messages.Heartbeat.str = 'Heartbeat'
Messages.Status.value = 2
Messages.Status.str = 'Status'
Messages.Command.value = 3
Messages.Command.str = 'Command'
Messages.Event.value = 4
Messages.Event.str = 'Event'
Messages.Data.value = 5
Messages.Data.str = 'Data'
Messages.Heartbeat.System.HEARTBEAT.payload = []
Messages.Status.Mission.MISSION_PHASE.payload = [{'name': 'Enum_Mission_Phase', 'datatype': 'enum', 'bitmask': False}]
Messages.Status.System.FLIGHT.payload = [{'name': 'FlightMode', 'datatype': 'enum', 'bitmask': False}, {'name': 'airspeed', 'datatype': 'int', 'bitmask': False}, {'name': 'groundspeed', 'datatype': 'int', 'bitmask': False}, {'name': 'heading', 'datatype': 'int', 'bitmask': False}, {'name': 'msl_alt', 'datatype': 'int', 'bitmask': False}, {'name': 'mgrs', 'datatype': 'string', 'bitmask': False}]
Messages.Status.System.POSITION.payload = [{'name': 'mgrs', 'datatype': 'string', 'bitmask': False}]
Messages.Status.System.NAVIGATION.payload = []
Messages.Status.System.FUEL.payload = []
Messages.Status.System.CONTROL.payload = []
Messages.Status.System.SYSTEMS.payload = []
Messages.Status.System.NAV.payload = []
Messages.Status.System.RADIO.payload = []
Messages.Status.System.PAYLOAD.payload = []
Messages.Command.System.ACTIVATE.payload = []
Messages.Command.System.SHUTDOWN.payload = []
Messages.Command.System.SET_FLIGHT_MODE.payload = []
Messages.Command.System.SWITCH_DATALINK.payload = []
Messages.Command.System.DATALINK_CONFIG.payload = []
Messages.Command.System.SET_FLIGHT_PARAMETERS.payload = []
Messages.Command.Mission.SET_MISSION.payload = [{'name': 'mission_index', 'datatype': 'int', 'bitmask': False}]
Messages.Command.Mission.SET_MISSION_MODE.payload = []
Messages.Command.Mission.TAKEOFF.payload = []
Messages.Command.Mission.ABORT.payload = []
Messages.Command.Mission.HOLD.payload = []
Messages.Command.Mission.PROCEED.payload = []
Messages.Command.Mission.REROUTE.payload = []
Messages.Command.Mission.REASSIGN.payload = []
Messages.Command.Mission.SET_WAYPOINT.payload = []
Messages.Command.Mission.SET_ZONE.payload = []
Messages.Command.Mission.NAVIGATE_TO.payload = [{'name': 'mgrs', 'datatype': 'string', 'bitmask': False}]
Messages.Command.Mission.LOITER.payload = []
Messages.Command.Mission.LAND.payload = []
Messages.Command.Mission.ALLOW_DEPLOY.payload = []
Messages.Command.Mission.ALLOW_ENGAGE.payload = []
Messages.Command.Mission.SWARM_CONTROL.payload = []
Messages.Event.Mission.PHASE.payload = [{'name': 'Enum_Mission_Phase', 'datatype': 'enum', 'bitmask': False}]
Messages.Event.System.ONLINE.payload = []
Messages.Event.System.GPS_FIX.payload = []
Messages.Event.System.ERROR.payload = []
Messages.Event.System.RADIO.payload = []
Messages.Event.System.RF_EVENT.payload = []
Messages.Event.System.FAILSAFE.payload = []
Messages.Event.System.HW_FAILURE.payload = []
Messages.Data.Mission.QUERY_MISSION_ID.payload = []
Messages.Data.Mission.QUERY_MISSION_PROGRESS.payload = []
Messages.Data.Mission.QUERY_CONTACTS.payload = []
Messages.Data.Mission.QUERY_SWARM_INFO.payload = []
Messages.Data.System.QUERY_SENSOR_DATA.payload = []
Messages.Data.System.QUERY_LOG_DATA.payload = []
Messages.Data.System.QUERY_DATALINK_STATUS.payload = []
Messages.Data.System.QUERY_NETWORK_STATUS.payload = []
Messages.Data.System.QUERY_SYSTEM_HEALTH.payload = []
Messages.Data.System.QUERY_TELEMETRY.payload = []

```

# message_definitions.json

```

{
    "Heartbeat": {
        "System": {
            "HEARTBEAT": []
        }
    },
    "Status": {
        "Mission": {
            "MISSION_PHASE": [
                {
                    "name": "Enum_Mission_Phase",
                    "datatype": "enum",
                    "bitmask": false
                }
            ]
        },
        "System": {
            "FLIGHT": [
                {
                    "name": "FlightMode",
                    "datatype": "enum",
                    "bitmask": false
                },
                {
                    "name": "airspeed",
                    "datatype": "int",
                    "bitmask": false
                },
                {
                    "name": "groundspeed",
                    "datatype": "int",
                    "bitmask": false
                },
                {
                    "name": "heading",
                    "datatype": "int",
                    "bitmask": false
                },
                {
                    "name": "msl_alt",
                    "datatype": "int",
                    "bitmask": false
                },
                {
                    "name": "mgrs",
                    "datatype": "string",
                    "bitmask": false
                }
            ],
            "POSITION": [
                {
                    "name": "mgrs",
                    "datatype": "string",
                    "bitmask": false
                }
            ],
            "NAVIGATION": [],
            "FUEL": [],
            "CONTROL": [],
            "SYSTEMS": [],
            "NAV": [],
            "RADIO": [],
            "PAYLOAD": []
        }
    },
    "Command": {
        "System": {
            "ACTIVATE": [],
            "SHUTDOWN": [],
            "SET_FLIGHT_MODE": [],
            "SWITCH_DATALINK": [],
            "DATALINK_CONFIG": [],
            "SET_FLIGHT_PARAMETERS": []
        },
        "Mission": {
            "SET_MISSION": [
                {
                    "name": "mission_index",
                    "datatype": "int",
                    "bitmask": false
                }
            ],
            "SET_MISSION_MODE": [],
            "TAKEOFF": [],
            "ABORT": [],
            "HOLD": [],
            "PROCEED": [],
            "REROUTE": [],
            "REASSIGN": [],
            "SET_WAYPOINT": [],
            "SET_ZONE": [],
            "NAVIGATE_TO": [
                {
                    "name": "mgrs",
                    "datatype": "string",
                    "bitmask": false
                }
            ],
            "LOITER": [],
            "LAND": [],
            "ALLOW_DEPLOY": [],
            "ALLOW_ENGAGE": [],
            "SWARM_CONTROL": []
        }
    },
    "Event": {
        "Mission": {
            "PHASE": [
                {
                    "name": "Enum_Mission_Phase",
                    "datatype": "enum",
                    "bitmask": false
                }
            ]
        },
        "System": {
            "ONLINE": [],
            "GPS_FIX": [],
            "ERROR": [],
            "RADIO": [],
            "RF_EVENT": [],
            "FAILSAFE": [],
            "HW_FAILURE": []
        }
    },
    "Data": {
        "Mission": {
            "QUERY_MISSION_ID": [],
            "QUERY_MISSION_PROGRESS": [],
            "QUERY_CONTACTS": [],
            "QUERY_SWARM_INFO": []
        },
        "System": {
            "QUERY_SENSOR_DATA": [],
            "QUERY_LOG_DATA": [],
            "QUERY_DATALINK_STATUS": [],
            "QUERY_NETWORK_STATUS": [],
            "QUERY_SYSTEM_HEALTH": [],
            "QUERY_TELEMETRY": []
        }
    }
}
```

# unavlib_example_mission.py

```

import asyncio
import time
from unavlib.control import UAVControl
from unavlib.modules import geospatial
from unavlib.modules.utils import inavutil

# Example Mission and use of UAVControl class
# Work in progress
# Uses X-Plane 11 HITL starting from Montreal Intl Airport
# set msp_override_channels =  14399
# Use receiver type MSP, set serialport below to your telemetry port (ie: USB-TTL converter)
# Mode settings:
# ID: 0 	ARM             :	0 (channel 5)	= 1800 to 2100
# ID: 1	    ANGLE           :	7 (channel 12)	= 900 to 1100
# ID: 11	NAV POSHOLD     :	7 (channel 12)	= 1100 to 1300
# ID: 10	NAV RTH         :	7 (channel 12)	= 1900 to 2100
# ID: 31	GCS NAV         :	7 (channel 12)	= 1100 to 1300
# ID: 27	FAILSAFE        :	4 (channel 9)	= 1600 to 2100
# ID: 50	MSP RC OVERRIDE :	1 (channel 6)	= 1400 to 1625
# Start, arm and set mode to Override, then run this

async def my_plan(uav):

    set_alt = 50

    uav.debugprint = False
    #uav.modes.keys() # show all currently programmed modes
    # create new supermode (combination of multiple modes)
    uav.new_supermode('GOTO', [inavutil.modesID.GCS_NAV, inavutil.modesID.NAV_POSHOLD])
    # assuming proper compile flag and bitmask config
    uav.set_mode(inavutil.modesID.MSP_RC_OVERRIDE, on=True)
    uav.set_mode(inavutil.modesID.ANGLE, on=True)
    #await asyncio.sleep(3)
    uav.arm_enable_check()
    await asyncio.sleep(1)
    uav.set_mode(inavutil.modesID.ARM, on=True)
    await asyncio.sleep(1)

    #takeoff
    print('takeoff')
    uav.set_rc_channel('throttle',2000)
    uavalt = uav.get_altitude()
    t=0
    while uavalt<set_alt :
        uav.set_rc_channel('throttle',2100)
        uav.set_rc_channel('pitch',1100)
        uavspeed = uav.get_gps_data()['speed']
        uavalt = uav.get_altitude()
        print('Speed:', uavspeed,'Alt:', uavalt)
        await asyncio.sleep(1)
        t+=1
        if t>30:
            print('Aborting')
            uav.stop()
            return 1

    await asyncio.sleep(3)

    # set waypoint and fly auto
    uav.set_rc_channel('pitch',1500)
    uav.set_supermode("GOTO", on=True)
    while inavutil.modesID.GCS_NAV not in uav.get_active_modes():
        await asyncio.sleep(1)
    wp = geospatial.GPSposition(45.487363, -73.812242, 50)
    uav.set_wp(255, 1, wp.lat, wp.lon, wp.alt, 0, 0, 0, 0)
    print(f"Navstatus: {uav.get_nav_status()}")

    gpsd = uav.get_gps_data()
    alt = uav.get_altitude()
    pos = geospatial.GPSposition(gpsd['lat'], gpsd['lon'], alt)
    vector = geospatial.gps_to_vector(pos, wp)
    while vector.dist>50:
        gpsd = uav.get_gps_data()
        speed = gpsd['speed']
        alt = uav.get_altitude()
        pos = geospatial.GPSposition(gpsd['lat'], gpsd['lon'], alt)
        vector = geospatial.gps_to_vector(pos, wp)
        gyro = uav.get_attitude()

        print('\n')
        print('Channels:', uav.channels)
        print('Active modes:', uav.get_active_modes())
        print('Position:', pos)
        print('Attitude:', gyro)
        print('Altitude:', alt)
        print('Vector to waypoint:', vector)
        print('Bearing:',vector.az - gyro['yaw'])
        await asyncio.sleep(1)

    # loiter a minute
    for i in range(60):
        print(60-i)
        await asyncio.sleep(1)

    # bring it back
    uav.set_supermode("GOTO", on=False)
    uav.set_mode(inavutil.modesID.NAV_RTH, on=True)

    # rth and land
    while alt > 1:
        gpsd = uav.get_gps_data()
        alt = uav.get_altitude()
        print('Distance to home:',gpsd['distanceToHome'])
        await asyncio.sleep(1)

    uav.stop()


async def main():
    mydrone = UAVControl(device='/dev/ttyUSB0', baudrate=115200, platform="AIRPLANE")
    mydrone.msp_override_channels=[1, 2, 3, 4, 5, 6, 12, 13, 14]
    uavctl.msp_receiver = True

    try:
        await mydrone.connect()
        print("Connected to the flight controller")
        flight_control_task = asyncio.create_task(mydrone.flight_loop())
        user_script_task = asyncio.create_task(my_plan(mydrone))
        await asyncio.gather(flight_control_task, user_script_task)
    finally:
        print('\nConnection closed')

if __name__ == '__main__':
    asyncio.run(main())

```

# unavlib_example_telemetry.py

```

# Simpler example not using the flight loop
import asyncio
import socket
import time
from collections import deque
from itertools import cycle 
from unavlib.control import UAVControl
from unavlib.control import geospatial
from unavlib.modules.utils import inavutil
from unavlib.modules.fast_functions import fastMSP
from unavlib.modules import geospatial
from unavlib import MSPy

async def main():
    loop_time = 1/10.0

    mydrone = UAVControl(
        device='/dev/ttyUSB0', 
        baudrate=115200, 
        platform="AIRPLANE"
        )
    print("Connected to the flight controller")
    mydrone.msp_receiver = False
    mydrone.debugprint = False
    
    try:
        await mydrone.connect()
        await mydrone.telemetry_init()
        mydrone.load_modes_config()

        while 1:
            t = time.time()

            #if mydrone.board.send_RAW_RC(mydrone.channels):
            #    dataHandler = mydrone.board.receive_msg()
            #    mydrone.board.process_recv_data(dataHandler)

            gpsd = mydrone.get_gps_data()
            speed = gpsd['speed']
            alt = mydrone.get_altitude()
            pos = geospatial.GPSposition(gpsd['lat'], gpsd['lon'], alt)
            gyro = mydrone.get_attitude()
            navstatus = mydrone.get_nav_status()

            print('\n')
            print("Channels:",mydrone.channels)
            print('Modes:', mydrone.board.CONFIG['mode'], mydrone.get_board_modes())
            print('Position:', pos)
            print('Attitude:', gyro)
            print('Altitude:', alt)
            print(f"Navstatus: {navstatus}")
            print(f"cpuload: {mydrone.board.CONFIG['cpuload']}")
            print(f"cycleTime: {mydrone.board.CONFIG['cycleTime']}")
            print(mydrone.get_board_modes())

            await asyncio.sleep(loop_time)

        mydrone.stop()
        

    finally:
        print('\nConnection closed')

if __name__ == '__main__':
    asyncio.run(main())

```

